#import "./nft.impl.jsligo" "NFTImplModule"

#import "../common/errors.mligo" "Errors"

#import "../common/assertions.jsligo" "Assertions"

//  operators 
/**
* Check if the intented transfer is sent from the same sender as from field, otherwise check if the sender is part of the operator authorized to receive this token
* @param operators :  operator bigmap
* @param from_ : transfer from address
* @param token_id : token_id to test  
*/

export const assert_authorisation = (
   operators: NFTImplModule.NFT.operators,
   from_: address,
   token_id: nat
): unit => {
   const sender_ = (Tezos.get_sender());
   if (sender_ != from_) {
      const authorized =
         match((Big_map.find_opt([from_, sender_], operators))) {
            when (Some(a)):
               a
            when (None()):
               Set.empty
         };
      if (! (Set.mem(token_id, authorized))) {
         return failwith(Errors.not_operator)
      }
   } else {
      return unit
   }
};

export const add_operator = (
   operators: NFTImplModule.NFT.operators,
   owner: address,
   operator: address,
   token_id: nat
): NFTImplModule.NFT.operators => {
   if (owner == operator) {
      return operators
   // assert_authorisation always allow the owner so this case is not relevant

   } else {
      Assertions.assert_update_permission(owner);
      let auth_tokens =
         match(Big_map.find_opt([owner, operator], operators)) {
            when (Some(ts)):
               ts
            when (None()):
               Set.empty
         };
      auth_tokens = Set.add(token_id, auth_tokens);
      return Big_map.update([owner, operator], Some(auth_tokens), operators)
   }
};

export const remove_operator = (
   operators: NFTImplModule.NFT.operators,
   owner: address,
   operator: address,
   token_id: nat
): NFTImplModule.NFT.operators => {
   if (owner == operator) {
      return operators
   // assert_authorisation always allow the owner so this case is not relevant

   } else {
      Assertions.assert_update_permission(owner);
      const auth_tokens: option<set<nat>> =
         match(Big_map.find_opt([owner, operator], operators)) {
            when (Some(ts)):
               do {
                  const toks = Set.remove(token_id, ts);
                  if (Set.cardinal(toks) == 0n) {
                     return None()
                  } else {
                     return Some(toks)
                  }
               }
            when (None()):
               None()
         };
      return Big_map.update([owner, operator], auth_tokens, operators)
   }
}

//  ledger 

export const is_owner_of = (
   ledger: NFTImplModule.NFT.ledger,
   token_id: nat,
   owner: address
): bool => {
   const current_owner = Option.unopt(Big_map.find_opt(token_id, ledger));
   return (current_owner == owner)
};

const assert_owner_of = (
   ledger: NFTImplModule.NFT.ledger,
   token_id: nat,
   owner: address
): unit =>
   assert_with_error(is_owner_of(ledger, token_id, owner), Errors.ins_balance);

export const transfer_token_from_user_to_user = (
   ledger: NFTImplModule.NFT.ledger,
   token_id: nat,
   from_: address,
   to_: address
): NFTImplModule.NFT.ledger => {
   assert_owner_of(ledger, token_id, from_);
   return Big_map.update(token_id, Some(to_), ledger)
}

export const set_ledger = (
   s: NFTImplModule.NFT.storage,
   ledger: NFTImplModule.NFT.ledger
): NFTImplModule.NFT.storage =>
   ({ ...s, ledger: ledger });

export const get_operators = (s: NFTImplModule.NFT.storage): NFTImplModule.
NFT.
operators =>
   s.operators;

export const set_operators = (
   s: NFTImplModule.NFT.storage,
   operators: NFTImplModule.NFT.operators
): NFTImplModule.NFT.storage =>
   ({ ...s, operators: operators });

@view
const get_balance = (p: [address, nat], s: NFTImplModule.NFT.storage): nat => {
   const [owner, token_id] = p;
   Assertions.assert_token_exist(s.token_metadata, token_id);
   if (is_owner_of(s.ledger, token_id, owner)) {
      return 1n
   } else {
      return 0n
   }
};

@view
const total_supply = (token_id: nat, s: NFTImplModule.NFT.storage): nat => {
   Assertions.assert_token_exist(s.token_metadata, token_id);
   return 1n
};

@view
const all_tokens = (_: unit, _s: NFTImplModule.NFT.storage): set<nat> =>
   failwith(Errors.not_available);

@view
const is_operator = (
   op: NFTImplModule.TZIP12.operator,
   s: NFTImplModule.NFT.storage
): bool => {
   const authorized =
      match(Big_map.find_opt([op.owner, op.operator], s.operators)) {
         when (Some(a)):
            a
         when (None()):
            Set.empty
      };
   return (Set.mem(op.token_id, authorized) || op.owner == op.operator)
};

@view
const token_metadata = (p: nat, s: NFTImplModule.NFT.storage): NFTImplModule.
TZIP12.
tokenMetadataData => {
   return match(Big_map.find_opt(p, s.token_metadata)) {
      when (Some(data)):
         data
      when (None()):
         failwith(Errors.undefined_token)
   }
}
